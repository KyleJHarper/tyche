1. Options
     a) [done] Consider a config file or long options if too many options become an issue.
     b) [done] Build a struct or something to hold the options and possibly link to it from the raw list?
     c) [done] -f == Fixed memory sizes.  No adaptive logic.  raw/comp lists won't be engine__balanced()'d
     d) [done] -w == Workers to use, defaults to number of CPUs
     e) [done] -d == Time to spend running the test, in seconds. (-d == duration)
     f) [done] -r == Hit ratio (minimum) to aim for.  (Only use known buffers when ratio too low)
     g) [done] -b == Bytes to limit data set to.  (Can point to large dir and stop at X bytes)
     h) [done] -n == Number of pages to limit tyche to scan for.
     i) [done] Update the show_help() function.
     j) [done] -t == Run test optarg.
2. Buffer Mutexes & Conditions
     a) Recalculate memory consumption remembering that largest data set == max memory we assign!
     b) Even if memory savings are minimal, are we saving CPU time by not initializing a new set for each buffer?
     c) If we need to go larger than uint16_t, we might as well use pointers; and this is probably a good idea.
        Make sure to confirm that pointers are 4 bytes, not 8.  Otherwise use uint32_t.
     d) Look at lock__acquire and lock__release; make static inline or simply put into buffer.c calls.
     e) Update the comments if we're keeping lock.h/.c.
3. Manager
     a) A new structure to manage the lists.  Functions for list review and adjustment.
     b) The primary function, manager__analyze(), is where ACCRS logic should do the real magic.
     c) Manager should be disabled when -F is specified.
     d) Manager should log output of decisions and supporting data.
     e) Research options to accommodate aging and if it's even necessary (newer buffers == more likely to reuse?)
     f) Ensure that a scan protection element exists.
4. Reporting
     a) Totals: buffers read, per second, peak?, etc
     b) Buffer hits, misses/faults, and hit ratio.
     c) Data set information: files found, average size, max size, minimum size, etc.
5. FAQ
     a) Why no size_t?  (Because I want to ensure minium sizes in almost all cases)
     b) Why so much uint/uintX_t?  Because I usually need to accommodate the given size and negative numbers don't exist.
     c) Why no <bla> optimization?  Probably because I'm new to C and didn't know about it.
     d) Why no linked list?  Because I wanted searching without maintaining a skip list.  (Is it even better?)
     e) Why C?  To *hopefully* avoid bias in higher level langages; though they might have optimizations.
     f) Why lz4?  Partly it's compression speed+efficiency, but mostly it's decompression speed.
     g) Locker?  In theory, it reduces memory use by using shared locks among a small number of buffers.  Configurable.
6. Optimizations
     a) Using const on all functions where appropriate.
     b) Figure out how to stop double-scanning with io__* to get the page count.
     c) Inline functions like lock__acquire/release (or simply remove them?)
7. Test Updates
     a) Modify all tests to accept and use the primary list set created by main().
     b) Update tests__elements test to be more... useful (and actually run).
     c) Update tests__io to actually work.
     d) Update tests__move_buffers to actually work.
     e) Add a timing component to all tests.
